{
  "api/NanoByte.SatSolver.Clause-1.html": {
    "href": "api/NanoByte.SatSolver.Clause-1.html",
    "title": "Class Clause<T> | NanoByte SAT Solver",
    "summary": "Class Clause<T> Namespace NanoByte.SatSolver Assembly NanoByte.SatSolver.dll A Boolean Clause. Consists of a set of Literal<T>s of which at least one must be true. public class Clause<T> : HashSet<Literal<T>>, ISerializable, IDeserializationCallback, ISet<Literal<T>>, ICollection<Literal<T>>, IReadOnlyCollection<Literal<T>>, IEnumerable<Literal<T>>, IEnumerable, IEquatable<Clause<T>> where T : IEquatable<T> Type Parameters T The underlying type used to identify/compare Literals. Inheritance object HashSet<Literal<T>> Clause<T> Implements ISerializable IDeserializationCallback ISet<Literal<T>> ICollection<Literal<T>> IReadOnlyCollection<Literal<T>> IEnumerable<Literal<T>> IEnumerable IEquatable<Clause<T>> Inherited Members HashSet<Literal<T>>.Clear() HashSet<Literal<T>>.Contains(Literal<T>) HashSet<Literal<T>>.CopyTo(Literal<T>[], int) HashSet<Literal<T>>.Remove(Literal<T>) HashSet<Literal<T>>.GetEnumerator() HashSet<Literal<T>>.GetObjectData(SerializationInfo, StreamingContext) HashSet<Literal<T>>.OnDeserialization(object) HashSet<Literal<T>>.Add(Literal<T>) HashSet<Literal<T>>.UnionWith(IEnumerable<Literal<T>>) HashSet<Literal<T>>.IntersectWith(IEnumerable<Literal<T>>) HashSet<Literal<T>>.ExceptWith(IEnumerable<Literal<T>>) HashSet<Literal<T>>.SymmetricExceptWith(IEnumerable<Literal<T>>) HashSet<Literal<T>>.IsSubsetOf(IEnumerable<Literal<T>>) HashSet<Literal<T>>.IsProperSubsetOf(IEnumerable<Literal<T>>) HashSet<Literal<T>>.IsSupersetOf(IEnumerable<Literal<T>>) HashSet<Literal<T>>.IsProperSupersetOf(IEnumerable<Literal<T>>) HashSet<Literal<T>>.Overlaps(IEnumerable<Literal<T>>) HashSet<Literal<T>>.SetEquals(IEnumerable<Literal<T>>) HashSet<Literal<T>>.CopyTo(Literal<T>[]) HashSet<Literal<T>>.CopyTo(Literal<T>[], int, int) HashSet<Literal<T>>.RemoveWhere(Predicate<Literal<T>>) HashSet<Literal<T>>.TrimExcess() HashSet<Literal<T>>.CreateSetComparer() HashSet<Literal<T>>.Count HashSet<Literal<T>>.Comparer object.Equals(object, object) object.ReferenceEquals(object, object) object.GetType() object.MemberwiseClone() Constructors Clause() Creates an empty Clause. public Clause() Clause(IEnumerable<Literal<T>>) Creates a Clause consisting the specified literals. public Clause(IEnumerable<Literal<T>> literals) Parameters literals IEnumerable<Literal<T>> Properties IsEmpty Indicates whether this Clause is empty and therefore unsatisfiable. public bool IsEmpty { get; } Property Value bool IsUnit Indicates whether this is a Unit Clause, i.e. contains exactly one Literal. public bool IsUnit { get; } Property Value bool Methods Equals(Clause<T>?) Indicates whether the current object is equal to another object of the same type. public bool Equals(Clause<T>? other) Parameters other Clause<T> An object to compare with this object. Returns bool true if the current object is equal to the other parameter; otherwise, false. Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. ToString() Returns a string that represents the current object. public override string ToString() Returns string A string that represents the current object. Without(Literal<T>) Returns a copy of this Clause without the specified literal. public Clause<T> Without(Literal<T> literal) Parameters literal Literal<T> Returns Clause<T> Operators operator &(Clause<T>, Clause<T>) Creates a Formula<T> consisting of two Clause<T>s. public static Formula<T> operator &(Clause<T> clause1, Clause<T> clause2) Parameters clause1 Clause<T> The first Clause. clause2 Clause<T> The second Clause. Returns Formula<T> operator |(Clause<T>, Literal<T>) Creates a Clause<T> consisting of all Literals from an existing Clause plus an additional Literal<T>. public static Clause<T> operator |(Clause<T> clause, Literal<T> literal) Parameters clause Clause<T> The existing Clause. literal Literal<T> The additional Literal. Returns Clause<T> operator |(Literal<T>, Clause<T>) Creates a Clause<T> consisting of all Literals from an existing Clause plus an additional Literal<T>. public static Clause<T> operator |(Literal<T> literal, Clause<T> clause) Parameters literal Literal<T> The additional Literal. clause Clause<T> The existing Clause. Returns Clause<T>"
  },
  "api/NanoByte.SatSolver.Clauses.html": {
    "href": "api/NanoByte.SatSolver.Clauses.html",
    "title": "Class Clauses | NanoByte SAT Solver",
    "summary": "Class Clauses Namespace NanoByte.SatSolver Assembly NanoByte.SatSolver.dll Static factory methods for Clause<T>. public static class Clauses Inheritance object Clauses Inherited Members object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Methods AtMostOne<T>(params Literal<T>[]) Creates Clauses that together prevent more than one of the specified literals from being true. public static IEnumerable<Clause<T>> AtMostOne<T>(params Literal<T>[] literals) where T : IEquatable<T> Parameters literals Literal<T>[] Returns IEnumerable<Clause<T>> Type Parameters T The underlying type used to identify/compare Literals. AtMostOne<T>(IEnumerable<Literal<T>>) Creates Clauses that together prevent more than one of the specified literals from being true. public static IEnumerable<Clause<T>> AtMostOne<T>(IEnumerable<Literal<T>> literals) where T : IEquatable<T> Parameters literals IEnumerable<Literal<T>> Returns IEnumerable<Clause<T>> Type Parameters T The underlying type used to identify/compare Literals. ExactlyOne<T>(params Literal<T>[]) Creates Clauses that together require exactly one of the specified literals to be true. public static IEnumerable<Clause<T>> ExactlyOne<T>(params Literal<T>[] literals) where T : IEquatable<T> Parameters literals Literal<T>[] Returns IEnumerable<Clause<T>> Type Parameters T The underlying type used to identify/compare Literals. ExactlyOne<T>(IEnumerable<Literal<T>>) Creates Clauses that together require exactly one of the specified literals to be true. public static IEnumerable<Clause<T>> ExactlyOne<T>(IEnumerable<Literal<T>> literals) where T : IEquatable<T> Parameters literals IEnumerable<Literal<T>> Returns IEnumerable<Clause<T>> Type Parameters T The underlying type used to identify/compare Literals."
  },
  "api/NanoByte.SatSolver.Formula-1.html": {
    "href": "api/NanoByte.SatSolver.Formula-1.html",
    "title": "Class Formula<T> | NanoByte SAT Solver",
    "summary": "Class Formula<T> Namespace NanoByte.SatSolver Assembly NanoByte.SatSolver.dll A Boolean Formula. Consists of a set of Clause<T>s which all must be true. public class Formula<T> : HashSet<Clause<T>>, ISerializable, IDeserializationCallback, ISet<Clause<T>>, ICollection<Clause<T>>, IReadOnlyCollection<Clause<T>>, IEnumerable<Clause<T>>, IEnumerable, IEquatable<Formula<T>> where T : IEquatable<T> Type Parameters T The underlying type used to identify/compare Literals. Inheritance object HashSet<Clause<T>> Formula<T> Implements ISerializable IDeserializationCallback ISet<Clause<T>> ICollection<Clause<T>> IReadOnlyCollection<Clause<T>> IEnumerable<Clause<T>> IEnumerable IEquatable<Formula<T>> Inherited Members HashSet<Clause<T>>.Clear() HashSet<Clause<T>>.Contains(Clause<T>) HashSet<Clause<T>>.CopyTo(Clause<T>[], int) HashSet<Clause<T>>.Remove(Clause<T>) HashSet<Clause<T>>.GetEnumerator() HashSet<Clause<T>>.GetObjectData(SerializationInfo, StreamingContext) HashSet<Clause<T>>.OnDeserialization(object) HashSet<Clause<T>>.Add(Clause<T>) HashSet<Clause<T>>.UnionWith(IEnumerable<Clause<T>>) HashSet<Clause<T>>.IntersectWith(IEnumerable<Clause<T>>) HashSet<Clause<T>>.ExceptWith(IEnumerable<Clause<T>>) HashSet<Clause<T>>.SymmetricExceptWith(IEnumerable<Clause<T>>) HashSet<Clause<T>>.IsSubsetOf(IEnumerable<Clause<T>>) HashSet<Clause<T>>.IsProperSubsetOf(IEnumerable<Clause<T>>) HashSet<Clause<T>>.IsSupersetOf(IEnumerable<Clause<T>>) HashSet<Clause<T>>.IsProperSupersetOf(IEnumerable<Clause<T>>) HashSet<Clause<T>>.Overlaps(IEnumerable<Clause<T>>) HashSet<Clause<T>>.SetEquals(IEnumerable<Clause<T>>) HashSet<Clause<T>>.CopyTo(Clause<T>[]) HashSet<Clause<T>>.CopyTo(Clause<T>[], int, int) HashSet<Clause<T>>.RemoveWhere(Predicate<Clause<T>>) HashSet<Clause<T>>.TrimExcess() HashSet<Clause<T>>.CreateSetComparer() HashSet<Clause<T>>.Count HashSet<Clause<T>>.Comparer object.Equals(object, object) object.ReferenceEquals(object, object) object.GetType() object.MemberwiseClone() Constructors Formula() Creates an empty Formula. public Formula() Formula(IEnumerable<Clause<T>>) Creates a Formula consisting the specified clauses. public Formula(IEnumerable<Clause<T>> clauses) Parameters clauses IEnumerable<Clause<T>> Properties ContainsEmptyClause Indicates whether this Formula contains any empty Clauses and is therefore unsatisfiable. public bool ContainsEmptyClause { get; } Property Value bool IsConsistent Indicates whether this Formula is a consistent set of Literals, i.e. consists only non-conflicting Unit Clauses. public bool IsConsistent { get; } Property Value bool Methods Equals(Formula<T>?) Indicates whether the current object is equal to another object of the same type. public bool Equals(Formula<T>? other) Parameters other Formula<T> An object to compare with this object. Returns bool true if the current object is equal to the other parameter; otherwise, false. Equals(object?) Determines whether the specified object is equal to the current object. public override bool Equals(object? obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. GetLiterals() Returns a set of all Literal<T>s referenced in the Formula. public IEnumerable<Literal<T>> GetLiterals() Returns IEnumerable<Literal<T>> GetPureLiterals() Returns a set of all Literal<T>s referenced in the Formula that are pure, i.e. do not occur both negated and non-negated. public IEnumerable<Literal<T>> GetPureLiterals() Returns IEnumerable<Literal<T>> Simplify() Returns a simplified copy of the Formula. This applies Unit propagation and Pure Literal elimination. public Formula<T> Simplify() Returns Formula<T> ToString() Returns a string that represents the current object. public override string ToString() Returns string A string that represents the current object. Operators operator &(Clause<T>, Formula<T>) Creates a Formula<T> consisting of all Clauses from an existing Formula plus an additional Clause<T>. public static Formula<T> operator &(Clause<T> clause, Formula<T> formula) Parameters clause Clause<T> The additional Clause. formula Formula<T> The existing Formula. Returns Formula<T> operator &(Formula<T>, Clause<T>) Creates a Formula<T> consisting of all Clauses from an existing Formula plus an additional Clause<T>. public static Formula<T> operator &(Formula<T> formula, Clause<T> clause) Parameters formula Formula<T> The existing Formula. clause Clause<T> The additional Clause. Returns Formula<T>"
  },
  "api/NanoByte.SatSolver.Literal-1.html": {
    "href": "api/NanoByte.SatSolver.Literal-1.html",
    "title": "Struct Literal<T> | NanoByte SAT Solver",
    "summary": "Struct Literal<T> Namespace NanoByte.SatSolver Assembly NanoByte.SatSolver.dll A Boolean Literal. public readonly struct Literal<T> : IEquatable<Literal<T>> where T : IEquatable<T> Type Parameters T The underlying type used to identify/compare Literals. Implements IEquatable<Literal<T>> Inherited Members object.Equals(object, object) object.ReferenceEquals(object, object) object.GetType() Constructors Literal(T, bool) Creates a Literal. public Literal(T value, bool negated = false) Parameters value T The underlying value used to identify/compare Literals. negated bool Indicates whether this Literal has been negated. Properties Negated Indicates whether this Literal has been negated. public bool Negated { get; } Property Value bool Value The underlying value used to identify/compare Literals. public T Value { get; } Property Value T Methods ConflictsWith(Literal<T>) Checks whether this Literal conflicts with the given literal. public bool ConflictsWith(Literal<T> literal) Parameters literal Literal<T> Returns bool Equals(Literal<T>) Indicates whether the current object is equal to another object of the same type. public bool Equals(Literal<T> other) Parameters other Literal<T> An object to compare with this object. Returns bool true if the current object is equal to the other parameter; otherwise, false. Equals(object?) Indicates whether this instance and a specified object are equal. public override bool Equals(object? obj) Parameters obj object The object to compare with the current instance. Returns bool true if obj and this instance are the same type and represent the same value; otherwise, false. GetHashCode() Returns the hash code for this instance. public override int GetHashCode() Returns int A 32-bit signed integer that is the hash code for this instance. IsPure(IEnumerable<Literal<T>>) Checks whether this Literal conflicts with any of the given literals. public bool IsPure(IEnumerable<Literal<T>> literals) Parameters literals IEnumerable<Literal<T>> Returns bool Negate() Returns a negated copy of this Literal. public Literal<T> Negate() Returns Literal<T> ToString() Returns the fully qualified type name of this instance. public override string ToString() Returns string The fully qualified type name. Operators operator &(Literal<T>, Literal<T>) Creates a Formula<T> consisting of two Clause<T>s, each containing a single Literal<T>. public static Formula<T> operator &(Literal<T> literal1, Literal<T> literal2) Parameters literal1 Literal<T> The Literal in the first Clause. literal2 Literal<T> The Literal in the second Clause. Returns Formula<T> operator |(Literal<T>, Literal<T>) Creates a Clause<T> consisting of two Literal<T>s. public static Clause<T> operator |(Literal<T> literal1, Literal<T> literal2) Parameters literal1 Literal<T> The first Literal in the Clause. literal2 Literal<T> The second Literal in the Clause. Returns Clause<T> operator ==(Literal<T>, Literal<T>) public static bool operator ==(Literal<T> left, Literal<T> right) Parameters left Literal<T> right Literal<T> Returns bool implicit operator Clause<T>(Literal<T>) Creates a Clause<T> consisting of a single Literal<T>. public static implicit operator Clause<T>(Literal<T> literal) Parameters literal Literal<T> The single Literal in the Clause. Returns Clause<T> implicit operator Literal<T>(T) Creates a Literal<T>. public static implicit operator Literal<T>(T value) Parameters value T The underlying value used to identify/compare Literals. Returns Literal<T> operator !=(Literal<T>, Literal<T>) public static bool operator !=(Literal<T> left, Literal<T> right) Parameters left Literal<T> right Literal<T> Returns bool operator !(Literal<T>) Returns a negated copy of this Literal. public static Literal<T> operator !(Literal<T> literal) Parameters literal Literal<T> Returns Literal<T>"
  },
  "api/NanoByte.SatSolver.Literal.html": {
    "href": "api/NanoByte.SatSolver.Literal.html",
    "title": "Class Literal | NanoByte SAT Solver",
    "summary": "Class Literal Namespace NanoByte.SatSolver Assembly NanoByte.SatSolver.dll Factory methods for Literal<T>s. public static class Literal Inheritance object Literal Inherited Members object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Methods Of<T>(T) Creates a Literal<T>. public static Literal<T> Of<T>(T value) where T : IEquatable<T> Parameters value T The underlying value used to identify/compare Literals. Returns Literal<T> Type Parameters T"
  },
  "api/NanoByte.SatSolver.Solver-1.html": {
    "href": "api/NanoByte.SatSolver.Solver-1.html",
    "title": "Class Solver<T> | NanoByte SAT Solver",
    "summary": "Class Solver<T> Namespace NanoByte.SatSolver Assembly NanoByte.SatSolver.dll A Boolean Satisfiability Solver. public class Solver<T> where T : IEquatable<T> Type Parameters T The underlying type used to identify/compare Literals. Inheritance object Solver<T> Inherited Members object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() Methods ChooseLiteral(Formula<T>) Picks a Literal<T> from the formula to assign a truth value to during backtracking. protected virtual Literal<T> ChooseLiteral(Formula<T> formula) Parameters formula Formula<T> Returns Literal<T> IsSatisfiable(Formula<T>) Checks whether this formula is satisfiable. public bool IsSatisfiable(Formula<T> formula) Parameters formula Formula<T> Returns bool"
  },
  "api/NanoByte.SatSolver.html": {
    "href": "api/NanoByte.SatSolver.html",
    "title": "Namespace NanoByte.SatSolver | NanoByte SAT Solver",
    "summary": "Namespace NanoByte.SatSolver DPLL Boolean Satisfiability Solver. Classes Clause<T> A Boolean Clause. Consists of a set of Literal<T>s of which at least one must be true. Clauses Static factory methods for Clause<T>. Formula<T> A Boolean Formula. Consists of a set of Clause<T>s which all must be true. Literal Factory methods for Literal<T>s. Solver<T> A Boolean Satisfiability Solver. Structs Literal<T> A Boolean Literal."
  },
  "index.html": {
    "href": "index.html",
    "title": "Home | NanoByte SAT Solver",
    "summary": "NanoByte SAT Solver NanoByte SAT Solver is a DPLL Boolean Satisfiability Solver for .NET. Usage Add a reference to the NanoByte.SatSolver NuGet package to your project. It is available for .NET Framework 2.0+ and .NET Standard 1.0+. You need to choose the underlying type to use for Literals in Boolean Formulas. This will often be int or string but you can also use any other type that implements the IEquatable<T> interface. You can then create an instance of Solver<T>: var solver = new Solver<string>(); The library enables you to express Boolean Formulas using implicit casting and operators for human-friendly sample and test code: Literal<string> a = \"a\", b = \"b\", c = \"c\", d = \"d\"; var formula = (a | b) & (!a | c) & (!c | d) & a; For constructing Formulas at run-time you can use a collection-like interface instead: var formula = new Formula<string> { new Clause<string> {Literal.Of(\"a\"), Literal.Of(\"b\")}, new Clause<string> {Literal.Of(\"a\").Negate(), Literal.Of(\"c\")}, new Clause<string> {Literal.Of(\"c\").Negate(), Literal.Of(\"d\")}, new Clause<string> {Literal.Of(\"a\")} }; Finally, you can use the solver to determine whether a Formula is satisfiable: bool result = solver.IsSatisfiable(formula); When the Solver needs to choose a Literal to assign a truth value to during backtracking, it simply picks the first unset Literal from the list. You can replace this with your own domain-specific logic for better performance by deriving from Solver<T> and overriding the ChooseLiteral() method."
  }
}